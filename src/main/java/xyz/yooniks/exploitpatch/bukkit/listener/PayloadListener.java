package xyz.yooniks.exploitpatch.bukkit.listener;

import com.comphenix.protocol.PacketType.Play.Client;
import com.comphenix.protocol.events.ListenerPriority;
import com.comphenix.protocol.events.PacketAdapter;
import com.comphenix.protocol.events.PacketContainer;
import com.comphenix.protocol.events.PacketEvent;
import com.comphenix.protocol.utility.StreamSerializer;
import io.netty.buffer.ByteBuf;
import java.io.ByteArrayInputStream;
import java.io.DataInputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.Callable;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.plugin.Plugin;
import xyz.yooniks.exploitpatch.bukkit.ExploitPatchLogger;
import xyz.yooniks.exploitpatch.bukkit.connection.ConnectionCloser;
import xyz.yooniks.exploitpatch.bukkit.nbt.NBTChecker;

public class PayloadListener extends PacketAdapter implements Listener {

  private final Callable<Integer> valueLoader = () -> 1;
  /*private final Cache<UUID, Integer> payloads = CacheBuilder.newBuilder()
      .expireAfterWrite(10, TimeUnit.SECONDS)
      .build();
  private final Map<UUID, Pair<Integer, Long>> editTimestamp = new HashMap<>();*/
  private final Map<UUID, PayloadInfo> payloadInfoMap = new HashMap<>();


  private final ConnectionCloser connectionCloser;
  private final int payloadLimit;
  private final List<String> blockedChannels;
  private final boolean bookDeserialization;

  private final List<NBTChecker> nbtCheckers;


  public PayloadListener(Plugin plugin, ConnectionCloser connectionCloser, int payloadLimit,
      List<String> blockedChannels, boolean bookDeserialization, List<NBTChecker> nbtCheckers) {
    super(plugin, ListenerPriority.LOWEST, Client.CUSTOM_PAYLOAD);
    this.connectionCloser = connectionCloser;
    this.payloadLimit = payloadLimit;
    this.blockedChannels = blockedChannels;
    this.bookDeserialization = bookDeserialization;
    this.nbtCheckers = nbtCheckers;
  }

  @Override
  public void onPacketReceiving(PacketEvent event) {
    final Player player = event.getPlayer();
    if (player == null || this.connectionCloser.isClosing(player)) {
      event.setCancelled(true);
      return;
    }
    if (player.getListeningPluginChannels().size() > 124) {
      event.setCancelled(true);
      this.connectionCloser.close(player);
      return;
    }
    final PacketContainer packet = event.getPacket();
    final String channel;
    if (packet.getStrings().size() < 1) {
      channel = packet.getMinecraftKeys().readSafely(0).getFullKey();
    } else {
      channel = packet.getStrings().readSafely(0);
    }
    if (this.blockedChannels.contains(channel.toLowerCase())) {
      event.setCancelled(true);
      this.connectionCloser.close(player);
      return;
    }

    final UUID uuid = player.getUniqueId();

    PayloadInfo payloadInfo = this.payloadInfoMap.get(uuid);
    if (payloadInfo == null) {
      this.payloadInfoMap.put(uuid, new PayloadInfo(1, System.currentTimeMillis()));
    } else {
      if (payloadInfo.lastPayloadTime + 300 > System.currentTimeMillis()) {
        event.setCancelled(true);
        payloadInfo.lastPayloadTime = System.currentTimeMillis();
        payloadInfo.sentPayloadsCount++;

        if (payloadInfo.sentPayloadsCount > this.payloadLimit) {
          event.setCancelled(true);
          ExploitPatchLogger.info(player.getName(), "Exceed payload limit!");
          this.connectionCloser.close(player);
        }
        return;
      } else {
        payloadInfo.sentPayloadsCount = 0;
        payloadInfo.lastPayloadTime = System.currentTimeMillis();
      }
    }

    if (channel.equalsIgnoreCase("MC|BEdit") || channel.equalsIgnoreCase("MC|BSign")
        || channel.equalsIgnoreCase("minecraft:bedit") || channel
        .equalsIgnoreCase("minecraft:bsign")) {
      if (this.bookDeserialization) {
        try {
          if (this.isInvalidNbt(event)) {
            event.setCancelled(true);
            ExploitPatchLogger.info(player.getName(), "Invalid book data in payloadPacket!");
            this.connectionCloser.close(player);
            return;
          }
        } catch (IOException ex) {
          ex.printStackTrace();
          event.setCancelled(true);
        }
        return;
      }
      event.setCancelled(true);
    }
    /*try {
      final int currentPayloads = this.payloads.get(player.getUniqueId(), this.valueLoader);
      this.payloads.put(player.getUniqueId(), currentPayloads + 1);

      if (currentPayloads > this.payloadLimit) {
        event.setCancelled(true);
        this.connectionCloser.close(player);
      }
    }
    catch (ExecutionException ex) {
      event.setCancelled(true);
    }*/
  }

  private boolean isInvalidNbt(PacketEvent event) throws IOException {
    PacketContainer container = event.getPacket();
    ByteBuf buffer = container.getSpecificModifier(ByteBuf.class).readSafely(0).copy();

    byte[] bytes = new byte[buffer.readableBytes()];
    buffer.readBytes(bytes);

    try (DataInputStream inputStream = new DataInputStream(new ByteArrayInputStream(bytes))) {
      ItemStack itemStack = StreamSerializer.getDefault().deserializeItemStack(inputStream);
      if (itemStack == null) {
        return true;
      }

      for (NBTChecker checker : this.nbtCheckers) {
        if (checker.isInvalid(event.getPlayer(), itemStack)) {
          return true;
        }
      }
      return false;
    } finally {
      buffer.release();
    }
  }

  @EventHandler
  public void onQuit(PlayerQuitEvent event) {
    this.payloadInfoMap.remove(event.getPlayer().getUniqueId());
  }

  private final class PayloadInfo {

    int sentPayloadsCount;
    long lastPayloadTime;

    PayloadInfo(int sentPayloadsCount, long lastPayloadTime) {
      this.sentPayloadsCount = sentPayloadsCount;
      this.lastPayloadTime = lastPayloadTime;
    }
  }


}
